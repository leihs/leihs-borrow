# source: http://localhost:3250/app/borrow/graphql
# timestamp: Tue May 12 2020 11:43:05 GMT+0200 (Central European Summer Time)

schema {
  query: QueryRoot
  mutation: MutationRoot
}

type Attachment {
  contentType: String!
  filename: String!
  id: UUID!
  size: Int!
  url: String!
}

type Availability {
  dates: [DayData]
}

type Category {
  children: [Category]
  id: UUID!
  images: [Image]

  """
  Includes only direct ones or all from self and the descendent sub-categories.
  """
  models(after: String, directOnly: Boolean, first: Int, orderBy: [ModelsOrderByInput], searchTerm: String): ModelsConnection

  """
  A name is either a label for the child-parent connection (if such exists) or the name of the category itself.
  """
  name: String!
}

type Contract {
  """
  A short, human-readable string to identify contracts instead of the much
  longer UUID. The format is optimized to be communicated verbally.
  """
  compactId: UUID!
  id: UUID!
  inventoryPool: InventoryPool!
  note: String
  purpose: String!
  state: String!
}

type ContractEdge {
  cursor: String!
  node: Contract!
}

type ContractsConnection {
  edges: [ContractEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ContractsOrderByAttributeEnum {
  ID
}

input ContractsOrderByInput {
  attribute: ContractsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

enum ContractStateEnum {
  OPEN
  CLOSED
}

type CurrentUser {
  favoriteModels(after: String, endDate: Date, first: Int, inventoryPoolIds: [UUID!], orderBy: [ModelsOrderByInput], searchTerm: String, startDate: Date): ModelsConnection
  inventoryPools(orderBy: [InventoryPoolsOrderByInput]): [InventoryPool]
  unsubmittedOrder: UnsubmittedOrder
  user: User
}

scalar Date

scalar DateTime

type DayData {
  date: Date!
  endDateRestriction: endDateRestrictionEnum
  quantity: Int!
  startDateRestriction: startDateRestrictionEnum
}

enum endDateRestrictionEnum {
  CLOSE_TIME
  VISITS_CAPACITY_REACHED
}

type Image {
  contentType: String!
  filename: String!
  id: UUID!
  imageUrl: String!
  size: Int!
  thumbnails: [Thumbnail]
}

type InventoryPool {
  email: String!
  id: UUID!
  name: String!
}

enum InventoryPoolsOrderByAttributeEnum {
  ID
  NAME
}

input InventoryPoolsOrderByInput {
  attribute: InventoryPoolsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

type Model {
  attachments: [Attachment]
  availability(endDate: Date!, inventoryPoolIds: [UUID!], startDate: Date!): [ModelInventoryPoolAvailability]
  availableQuantityInDateRange(endDate: Date!, excludeReservationIds: [UUID!], inventoryPoolIds: [UUID!], startDate: Date!): Int!
  description: String
  id: UUID!
  images: [Image]
  isFavorited: Boolean!
  isReservable: Boolean!
  manufacturer: String

  """A name consists of product name and its version."""
  name: String!
  properties: [Property]
  recommends(first: Int): ModelsConnection
}

type ModelEdge {
  cursor: String!
  node: Model!
}

type ModelInventoryPoolAvailability {
  dates: [DayData]
  inventoryPool: InventoryPool!
}

type ModelsConnection {
  edges: [ModelEdge]
  pageInfo: PageInfo!
  totalCount: Int
}

enum ModelsOrderByAttributeEnum {
  ID
  NAME
}

input ModelsOrderByInput {
  attribute: ModelsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

"""Root of all mutations."""
type MutationRoot {
  createReservation(
    endDate: Date!
    excludeReservationIds: [UUID!]

    """
    If it is not used, then the individual reservations are distributed among
    all inventory pools, where the user has access to and the available quantity
    within the pool is greater than zero.
    """
    inventoryPoolIds: [UUID!]
    modelId: UUID!
    quantity: Int!
    startDate: Date!
  ): [Reservation]
  deleteReservationLines(ids: [UUID!]): [UUID!]
  favoriteModel(id: UUID!): Model!
  refreshTimeout: RefreshTimeoutResult
  submitOrder(purpose: String!): Order!
  unfavoriteModel(id: UUID!): Model!
}

type Order {
  createdAt: DateTime!
  id: UUID!
  purpose: String!

  """List of distinct states of all the sub-orders."""
  state: [PoolOrderStateEnum]
  subOrdersByPool(orderBy: [PoolOrdersOrderByInput]): [PoolOrder]
  updatedAt: DateTime!
}

enum OrderByDirectionEnum {
  ASC
  DESC
}

type OrderEdge {
  cursor: String!
  node: Order!
}

type OrdersConnection {
  edges: [OrderEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum OrdersOrderByAttributeEnum {
  ID
  CREATED_AT
}

input OrdersOrderByInput {
  attribute: OrdersOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean
}

type PoolOrder {
  createdAt: DateTime!
  id: UUID!
  inventoryPool: InventoryPool!
  rejectedReason: String
  reservations(orderBy: [ReservationsOrderByInput]): [Reservation]
  state: PoolOrderStateEnum!
  updatedAt: DateTime!
}

enum PoolOrdersOrderByAttributeEnum {
  INVENTORY_POOL_ID
  ID
}

input PoolOrdersOrderByInput {
  attribute: PoolOrdersOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

enum PoolOrderStateEnum {
  SUBMITTED
  APPROVED
  REJECTED
}

type Property {
  id: UUID!
  key: String!
  value: String!
}

"""Root of all queries."""
type QueryRoot {
  category(id: UUID!, parentId: UUID): Category
  contracts(after: String, first: Int, orderBy: [ContractsOrderByInput], states: [ContractStateEnum]): ContractsConnection
  currentUser: CurrentUser!
  inventoryPools(orderBy: [InventoryPoolsOrderByInput]): [InventoryPool]
  model(id: UUID!): Model!
  models(after: String, categoryId: UUID, first: Int, ids: [UUID!], isFavorited: Boolean, onlyAvailable: Boolean, orderBy: [ModelsOrderByInput], quantity: Int, searchTerm: String): ModelsConnection
  order(id: UUID!): Order!
  orders(
    after: String
    first: Int
    orderBy: [OrdersOrderByInput]

    """
    Finds orders where the list of distinct states of the pool orders set-equals the distinct values of this argument.
    """
    states: [PoolOrderStateEnum]
  ): OrdersConnection
  rootCategories(limit: Int): [Category!]
  users(limit: Int, offset: Int, orderBy: [UsersOrderByInput], searchTerm: String): [User]
  visits(limit: Int, orderBy: [VisitsOrderByInput]): [Visit]
}

type RefreshTimeoutResult {
  unsubmittedOrder: UnsubmittedOrder
}

type Reservation {
  createdAt: DateTime!
  endDate: Date!
  id: UUID!
  inventoryPool: InventoryPool!
  model: Model!
  startDate: Date!
  status: ReservationStateEnum!
  updatedAt: DateTime!
}

enum ReservationsOrderByAttributeEnum {
  ID
}

input ReservationsOrderByInput {
  attribute: ReservationsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

enum ReservationStateEnum {
  UNSUBMITTED
  SUBMITTED
  APPROVED
  REJECTED
  SIGNED
  CLOSED
}

enum startDateRestrictionEnum {
  CLOSE_TIME
  VISITS_CAPACITY_REACHED
  BEFORE_EARLIEST_POSSIBLE_PICK_UP_DATE
}

type Thumbnail {
  contentType: String!
  filename: String!
  id: UUID!
  imageUrl: String!
  size: Int!
}

type UnsubmittedOrder {
  reservations: [Reservation]
  validUntil: DateTime
}

"""
A `User` represents a human agent that can log into and use the system.
"""
type User {
  contracts: ContractsConnection
  email: String
  firstname: String
  id: UUID!
  lastname: String
  login: String
}

enum UsersOrderByAttributeEnum {
  ID
}

input UsersOrderByInput {
  attribute: UsersOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

scalar UUID

type Visit {
  date: Date!
  id: UUID!
  inventoryPool: InventoryPool!
  isApproved: Boolean!
  quantity: Int!
  reservations(orderBy: [ReservationsOrderByInput]): [Reservation]
  visitType: VisitTypeEnum!
}

enum VisitsOrderByAttributeEnum {
  DATE
}

input VisitsOrderByInput {
  attribute: VisitsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

enum VisitTypeEnum {
  PICKUP
  RETURN
}
