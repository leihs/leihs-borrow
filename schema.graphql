# source: http://localhost:3250/borrow/graphql
# timestamp: Mon Dec 02 2019 14:35:56 GMT+0100 (Central European Standard Time)

schema {
  query: QueryRoot
  mutation: MutationRoot
}

type Attachment {
  contentType: String!
  filename: String!
  id: UUID!
  size: Int!
  url: String!
}

type Availability {
  dates: [DayData]
}

type Category {
  children: [Category]
  id: UUID!
  images: [Image]

  """
  Includes only direct ones or all from self and the descendent sub-categories.
  """
  models(directOnly: Boolean, limit: Int, offset: Int, orderBy: [ModelsOrderByInput], searchTerm: String): ModelsConnection

  """
  A name is either a label for the child-parent connection (if such exists) or the name of the category itself.
  """
  name: String!
}

type Contract {
  """
  A short, human-readable string to identify contracts instead of the much
  longer UUID. The format is optimized to be communicated verbally.
  """
  compactId: UUID!
  id: UUID!
  inventoryPool: InventoryPool!
  note: String
  purpose: String!
  state: String!
}

type ContractEdge {
  cursor: String!
  node: Contract!
}

type ContractsConnection {
  edges: [ContractEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ContractsOrderByAttributeEnum {
  ID
}

input ContractsOrderByInput {
  attribute: ContractsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

enum ContractStateEnum {
  OPEN
  CLOSED
}

type CurrentUser {
  favoriteModels(after: String, endDate: String, first: Int, inventoryPoolIds: [UUID!], orderBy: [ModelsOrderByInput], searchTerm: String, startDate: String): ModelsConnection
  inventoryPools(orderBy: [InventoryPoolsOrderByInput]): [InventoryPool]
  unsubmittedOrder: UnsubmittedOrder
  user: User
}

scalar DateTime

type DayData {
  date: String!
  quantity: Int!
  visitsCount: Int!
}

type Image {
  contentType: String!
  filename: String!
  id: UUID!
  imageUrl: String!
  size: Int!
  thumbnails: [Thumbnail]
}

type InventoryPool {
  email: String!
  id: UUID!
  name: String!
}

enum InventoryPoolsOrderByAttributeEnum {
  ID
  NAME
}

input InventoryPoolsOrderByInput {
  attribute: InventoryPoolsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

type Model {
  attachments: [Attachment]
  availability: [ModelInventoryPoolAvailability]
  availableQuantityInDateRange: Int!
  description: String
  id: UUID!
  images: [Image]
  isFavorited: Boolean!
  isReservable: Boolean!
  manufacturer: String

  """A name consists of product name and its version."""
  name: String!
  properties: [Property]
  recommends: ModelsConnection
}

type ModelEdge {
  cursor: String!
  node: Model!
}

type ModelInventoryPoolAvailability {
  dates: [DayData]
  inventoryPool: InventoryPool!
}

type ModelsConnection {
  edges: [ModelEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum ModelsOrderByAttributeEnum {
  ID
}

input ModelsOrderByInput {
  attribute: ModelsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

"""Root of all mutations."""
type MutationRoot {
  createReservation(
    endDate: String!

    """
    If it is not used, then the individual reservations are distributed among
    all inventory pools, where the user has access to and the available quantity
    within the pool is greater than zero.
    """
    inventoryPoolIds: [UUID!]
    modelId: UUID!
    quantity: Int!
    startDate: String!
  ): [Reservation]
  deleteReservations(ids: [UUID!]): [UUID!]
  favoriteModel(id: UUID!): Model!
  submitOrder(purpose: String!): Order!
  unfavoriteModel(id: UUID!): Model!
}

type Order {
  createdAt: DateTime!
  id: UUID!
  purpose: String!

  """List of distinct states of all the sub-orders."""
  state: [PoolOrderStateEnum]
  subOrdersByPool(orderBy: [PoolOrdersOrderByInput]): [PoolOrder]
  updatedAt: DateTime!
}

enum OrderByDirectionEnum {
  ASC
  DESC
}

type OrderEdge {
  cursor: String!
  node: Order!
}

type OrdersConnection {
  edges: [OrderEdge]
  pageInfo: PageInfo!
  totalCount: Int!
}

enum OrdersOrderByAttributeEnum {
  ID
}

input OrdersOrderByInput {
  attribute: OrdersOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
}

type PoolOrder {
  createdAt: DateTime!
  id: UUID!
  inventoryPool: InventoryPool!
  rejectedReason: String
  reservations(orderBy: [ReservationsOrderByInput]): [Reservation]
  state: PoolOrderStateEnum!
  updatedAt: DateTime!
}

enum PoolOrdersOrderByAttributeEnum {
  INVENTORY_POOL_ID
  ID
}

input PoolOrdersOrderByInput {
  attribute: PoolOrdersOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

enum PoolOrderStateEnum {
  SUBMITTED
  APPROVED
  REJECTED
}

type Property {
  id: UUID!
  key: String!
  value: String!
}

"""Root of all queries."""
type QueryRoot {
  availability(endDate: String!, inventoryPoolId: UUID!, modelId: UUID!, startDate: String!): Availability
  categories(ids: [UUID!], limit: Int, offset: Int, rootOnly: Boolean): [Category]
  contracts(after: String, first: Int, orderBy: [ContractsOrderByInput], states: [ContractStateEnum]): ContractsConnection
  currentUser: CurrentUser!
  inventoryPools: [InventoryPool]
  models(after: String, categoryIds: [UUID!], endDate: String, first: Int, ids: [UUID!], inventoryPoolIds: [UUID!], orderBy: [ModelsOrderByInput], searchTerm: String, startDate: String): ModelsConnection
  order(id: UUID!): Order!
  orders(
    after: String
    first: Int
    orderBy: [OrdersOrderByInput]

    """
    Finds orders where the list of distinct states of the pool orders set-equals the distinct values of this argument.
    """
    states: [PoolOrderStateEnum]
  ): OrdersConnection
  users(limit: Int, offset: Int, orderBy: [UsersOrderByInput], searchTerm: String): [User]
  visits(limit: Int, orderBy: [VisitsOrderByInput]): [Visit]
}

type Reservation {
  createdAt: DateTime!
  endDate: String!
  id: UUID!
  inventoryPool: InventoryPool!
  model: Model!
  startDate: String!
  status: ReservationStateEnum!
  updatedAt: DateTime!
}

enum ReservationsOrderByAttributeEnum {
  ID
}

input ReservationsOrderByInput {
  attribute: ReservationsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

enum ReservationStateEnum {
  UNSUBMITTED
  SUBMITTED
  APPROVED
  REJECTED
  SIGNED
  CLOSED
}

type Thumbnail {
  contentType: String!
  filename: String!
  id: UUID!
  imageUrl: String!
  size: Int!
}

type UnsubmittedOrder {
  reservations: [Reservation]
  validUntil: DateTime
}

"""
A `User` represents a human agent that can log into and use the system.
"""
type User {
  contracts: ContractsConnection
  email: String
  firstname: String
  id: UUID!
  lastname: String
  login: String
}

enum UsersOrderByAttributeEnum {
  ID
}

input UsersOrderByInput {
  attribute: UsersOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

scalar UUID

type Visit {
  date: String!
  id: UUID!
  inventoryPool: InventoryPool!
  isApproved: Boolean!
  quantity: Int!
  reservations(orderBy: [ReservationsOrderByInput]): [Reservation]
  visitType: VisitTypeEnum!
}

enum VisitsOrderByAttributeEnum {
  DATE
}

input VisitsOrderByInput {
  attribute: VisitsOrderByAttributeEnum!
  direction: OrderByDirectionEnum!
}

enum VisitTypeEnum {
  PICKUP
  RETURN
}
